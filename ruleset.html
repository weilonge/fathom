

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Rule and Ruleset Reference &mdash; Fathom 2.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/tweaks.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Fathom 2.0 documentation" href="index.html"/>
        <link rel="next" title="Utility Functions" href="utilities.html"/>
        <link rel="prev" title="Using Fathom" href="using.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Fathom
          

          
          </a>

          
            
            
              <div class="version">
                2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="using.html">Using Fathom</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Rule and Ruleset Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#rulesets">Rulesets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rules">Rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#left-hand-sides">Left-hand Sides</a></li>
<li class="toctree-l3"><a class="reference internal" href="#right-hand-sides">Right-hand Sides</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Utility Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="versions.html">Version History</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Fathom</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 







<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Rule and Ruleset Reference</li>
    <li class="wy-breadcrumbs-aside">
      
          
          <a href="_sources/ruleset.rst.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="rule-and-ruleset-reference">
<h1>Rule and Ruleset Reference<a class="headerlink" href="#rule-and-ruleset-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="rulesets">
<h2>Rulesets<a class="headerlink" href="#rulesets" title="Permalink to this headline">¶</a></h2>
<p>The top-level Fathom object is the ruleset, an unordered collection of rules. The plain old <a class="reference internal" href="#Ruleset" title="Ruleset"><code class="xref js js-class docutils literal"><span class="pre">Ruleset()</span></code></a> is what you typically construct, via the <code class="docutils literal"><span class="pre">ruleset</span></code> convenience function:</p>
<dl class="function">
<dt id="ruleset">
<code class="descname">ruleset</code><span class="sig-paren">(</span><em>rule</em><span class="optional">[</span>, <em>rule</em>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ruleset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#Ruleset" title="Ruleset"><code class="xref js js-class docutils literal"><span class="pre">Ruleset()</span></code></a> containing the given rules.</p>
</dd></dl>

<dl class="class">
<dt id="Ruleset">
<em class="property">class </em><code class="descname">Ruleset</code><span class="sig-paren">(</span><em>rule</em><span class="optional">[</span>, <em>rule</em>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#Ruleset" title="Permalink to this definition">¶</a></dt>
<dd><p>An unbound ruleset. Eventually, you&#8217;ll be able to add rules to these. Then,
when you bind them by calling <a class="reference internal" href="#Ruleset.against" title="Ruleset.against"><code class="xref js js-func docutils literal"><span class="pre">against()</span></code></a>, the resulting
<a class="reference internal" href="#BoundRuleset" title="BoundRuleset"><code class="xref js js-class docutils literal"><span class="pre">BoundRuleset()</span></code></a> will be immutable.</p>
<dl class="function">
<dt id="Ruleset.against">
<code class="descclassname">Ruleset.</code><code class="descname">against</code><span class="sig-paren">(</span><em>doc</em><span class="sig-paren">)</span><a class="headerlink" href="#Ruleset.against" title="Permalink to this definition">¶</a></dt>
<dd><p>Commit this ruleset to running against a specific DOM tree.</p>
<p>This doesn&#8217;t actually modify the Ruleset but rather returns a fresh
BoundRuleset, which contains caches and other stateful, per-DOM
bric-a-brac.</p>
</dd></dl>

<dl class="function">
<dt id="Ruleset.rules">
<code class="descclassname">Ruleset.</code><code class="descname">rules</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Ruleset.rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all the rules (both inward and outward) that make up this ruleset.</p>
<p>From this, you can construct another ruleset like this one but with your
own rules added.</p>
</dd></dl>

</dd></dl>

<p>Then you call <a class="reference internal" href="#Ruleset.against" title="Ruleset.against"><code class="xref js js-func docutils literal"><span class="pre">Ruleset.against()</span></code></a> to get back a <a class="reference internal" href="#BoundRuleset" title="BoundRuleset"><code class="xref js js-class docutils literal"><span class="pre">BoundRuleset()</span></code></a>, which is specific to a given DOM tree. From that, you pull answers.</p>
<dl class="class">
<dt id="BoundRuleset">
<em class="property">class </em><code class="descname">BoundRuleset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#BoundRuleset" title="Permalink to this definition">¶</a></dt>
<dd><p>A ruleset that is earmarked to analyze a certain DOM</p>
<p>Carries a cache of rule results on that DOM. Typically comes from
<a class="reference internal" href="#Ruleset.against" title="Ruleset.against"><code class="xref js js-func docutils literal"><span class="pre">Ruleset.against()</span></code></a>.</p>
<dl class="function">
<dt id="BoundRuleset.get">
<code class="descclassname">BoundRuleset.</code><code class="descname">get</code><span class="sig-paren">(</span><em>thing</em><span class="sig-paren">)</span><a class="headerlink" href="#BoundRuleset.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of zero or more fnodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>thing</strong> (<em>string|Lhs|Node</em>) &#8211; <p>Can be...</p>
<blockquote>
<div><ul>
<li>A string which matches up with an &#8220;out&#8221; rule in the ruleset. If the
out rule uses through(), the results of through&#8217;s callback (which
might not be fnodes) will be returned.</li>
<li>An arbitrary LHS which we calculate and return the results of</li>
<li>A DOM node, for which we will return the corresponding fnode</li>
</ul>
</div></blockquote>
<p>Results are cached in the first and third cases.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="rules">
<h2>Rules<a class="headerlink" href="#rules" title="Permalink to this headline">¶</a></h2>
<p>These are the control structures which govern the flow of scores, types, and notes through a ruleset. You construct a rule by calling <a class="reference internal" href="#rule" title="rule"><code class="xref js js-func docutils literal"><span class="pre">rule()</span></code></a> and passing it a left-hand side and a right-hand side:</p>
<dl class="function">
<dt id="rule">
<code class="descname">rule</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct and return the proper type of rule class based on the
inwardness/outwardness of the RHS.</p>
</dd></dl>

<div class="section" id="left-hand-sides">
<h3>Left-hand Sides<a class="headerlink" href="#left-hand-sides" title="Permalink to this headline">¶</a></h3>
<p>Left-hand sides are currently a few special forms which select nodes to be fed to right-hand sides.</p>
<dl class="function">
<dt id="dom">
<code class="descname">dom</code><span class="sig-paren">(</span><em>selector</em><span class="sig-paren">)</span><a class="headerlink" href="#dom" title="Permalink to this definition">¶</a></dt>
<dd><p>Take nodes that match a given DOM selector. Example:
<code class="docutils literal"><span class="pre">dom('meta[property=&quot;og:title&quot;]')</span></code></p>
<p>Every ruleset has at least one <code class="docutils literal"><span class="pre">dom</span></code> rule, as that is where nodes begin to
flow into the system.</p>
</dd></dl>

<dl class="function">
<dt id="type">
<code class="descname">type</code><span class="sig-paren">(</span><em>theType</em><span class="sig-paren">)</span><a class="headerlink" href="#type" title="Permalink to this definition">¶</a></dt>
<dd><p>Take nodes that have the given type. Example: <code class="docutils literal"><span class="pre">type('titley')</span></code></p>
<dl class="function">
<dt id="max">
<code class="descname">max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#max" title="Permalink to this definition">¶</a></dt>
<dd><p>Of the nodes selected by a <code class="docutils literal"><span class="pre">type</span></code> call to the left, constrain the LHS
to return only the max-scoring one. If there is a tie, more than 1 node
will be returned. Example: <code class="docutils literal"><span class="pre">type('titley').max()</span></code></p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="and">
<code class="descname">and</code><span class="sig-paren">(</span><em>typeCall</em><span class="optional">[</span>, <em>typeCall</em>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#and" title="Permalink to this definition">¶</a></dt>
<dd><p>Experimental. Pull nodes that conform to multiple conditions at once.</p>
<p>For example: <code class="docutils literal"><span class="pre">and(type('title'),</span> <span class="pre">type('english'))</span></code></p>
<p>Caveats: <code class="docutils literal"><span class="pre">and</span></code> supports only simple <code class="docutils literal"><span class="pre">type</span></code> calls as arguments for now,
and it may fire off more rules as prerequisites than strictly necessary.
<code class="docutils literal"><span class="pre">not</span></code> and <code class="docutils literal"><span class="pre">or</span></code> don&#8217;t exist yet, but you can express <code class="docutils literal"><span class="pre">or</span></code> the long way
around by having 2 rules with identical RHSs.</p>
</dd></dl>

</div>
<div class="section" id="right-hand-sides">
<h3>Right-hand Sides<a class="headerlink" href="#right-hand-sides" title="Permalink to this headline">¶</a></h3>
<p>A right-hand side takes the nodes chosen by the left-hand side and mutates them. Spelling-wise, a RHS is a strung-together series of calls like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="s1">&#39;smoo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">props</span><span class="p">(</span><span class="n">someCallback</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="s1">&#39;whee&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Calls layer together like sheets of transparent acetate: if there are repeats, as with <code class="docutils literal"><span class="pre">type</span></code> in the previous example, the rightmost takes precedence and the left becomes useless. Similarly, if <a class="reference internal" href="#props" title="props"><code class="xref js js-func docutils literal"><span class="pre">props()</span></code></a>, which can return multiple properties of a fact (element, note, score, and type), is missing any of these properties, we continue searching to the left for anything that provides them (excepting other :func:props` calls—if you want that, write a combinator, and use it to combine the 2 functions you want)). To prevent this, return all properties explicitly from your props callback, even if they are no-ops (like <code class="docutils literal"><span class="pre">{score:</span> <span class="pre">1,</span> <span class="pre">note:</span> <span class="pre">undefined,</span> <span class="pre">type:</span> <span class="pre">undefined}</span></code>). Aside from this layering precedence, the order of calls does not matter.</p>
<p>A good practice is to use more declarative calls—<a class="reference internal" href="#score" title="score"><code class="xref js js-func docutils literal"><span class="pre">score()</span></code></a>, <a class="reference internal" href="#note" title="note"><code class="xref js js-func docutils literal"><span class="pre">note()</span></code></a>, and <a class="reference internal" href="#type" title="type"><code class="xref js js-func docutils literal"><span class="pre">type()</span></code></a>—as much as possible and save <a class="reference internal" href="#props" title="props"><code class="xref js js-func docutils literal"><span class="pre">props()</span></code></a> for when you need it. The query planner can get more out of the more specialized calls without you having to tack on verbose hints like <a class="reference internal" href="#atMost" title="atMost"><code class="xref js js-func docutils literal"><span class="pre">atMost()</span></code></a> or <a class="reference internal" href="#typeIn" title="typeIn"><code class="xref js js-func docutils literal"><span class="pre">typeIn()</span></code></a>.</p>
<dl class="function">
<dt id="atMost">
<code class="descname">atMost</code><span class="sig-paren">(</span><em>score</em><span class="sig-paren">)</span><a class="headerlink" href="#atMost" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare that the maximum returned score multiplier is such and such,
which helps the optimizer plan efficiently. This doesn&#8217;t force it to be
true; it merely throws an error at runtime if it isn&#8217;t. To lift an
<code class="docutils literal"><span class="pre">atMost</span></code> constraint, call <code class="docutils literal"><span class="pre">atMost()</span></code> (with no args). The reason
<code class="docutils literal"><span class="pre">atMost</span></code> and <code class="docutils literal"><span class="pre">typeIn</span></code> apply until explicitly cleared is so that, if
someone used them for safety reasons on a lexically distant rule you are
extending, you won&#8217;t stomp on their constraint and break their
invariants accidentally.</p>
</dd></dl>

<dl class="function">
<dt id="conserveScore">
<code class="descname">conserveScore</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#conserveScore" title="Permalink to this definition">¶</a></dt>
<dd><p>Base the scores this RHS applies on the scores of the input nodes rather
than starting over from 1.</p>
<p>For now, there is no way to turn this back off (for example with a later
application of <code class="docutils literal"><span class="pre">props</span></code> or <code class="docutils literal"><span class="pre">conserveScore(false)</span></code>).</p>
</dd></dl>

<dl class="function">
<dt id="props">
<code class="descname">props</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#props" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine any of type, note, score, and element using a callback. This
overrides any previous call to <cite>props</cite> and, depending on what
properties of the callback&#8217;s return value are filled out, may override
the effects of other previous calls as well.</p>
<p>The callback should return...</p>
<ul class="simple">
<li>An optional score multiplier</li>
<li>A type (required on <code class="docutils literal"><span class="pre">dom(...)</span></code> rules, defaulting to the input one on
<code class="docutils literal"><span class="pre">type(...)</span></code> rules)</li>
<li>Optional notes</li>
<li>An element, defaulting to the input one. Overriding the default
enables a callback to walk around the tree and say things about nodes
other than the input one.</li>
</ul>
<p>For example...</p>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">fnode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[{</span><span class="nx">score</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
             <span class="nx">element</span><span class="o">:</span> <span class="nx">fnode</span><span class="p">.</span><span class="nx">element</span><span class="p">,</span>  <span class="c1">// unnecessary, since this is the default</span>
             <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;texty&#39;</span><span class="p">,</span>
             <span class="nx">note</span><span class="o">:</span> <span class="p">{</span><span class="nx">suspicious</span><span class="o">:</span> <span class="kc">true</span><span class="p">}}];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you use <code class="docutils literal"><span class="pre">props</span></code>, Fathom cannot look inside your callback to see what type you are emitting, so you must declare your output types with <a class="reference internal" href="#typeIn" title="typeIn"><code class="xref js js-func docutils literal"><span class="pre">typeIn()</span></code></a> or set a single static type with <code class="docutils literal"><span class="pre">type</span></code>. Fathom will complain if you don&#8217;t. (You can still opt not to return any type if the node turns out not to be a good match, even if you declare a <a class="reference internal" href="#typeIn" title="typeIn"><code class="xref js js-func docutils literal"><span class="pre">typeIn()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="note">
<code class="descname">note</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#note" title="Permalink to this definition">¶</a></dt>
<dd><p>Whatever the callback returns (even <code class="docutils literal"><span class="pre">undefined</span></code>) becomes the note of
the fact. This overrides any previous call to <code class="docutils literal"><span class="pre">note</span></code>.</p>
<p>Since every node can have multiple, independent notes (one for each type), this applies to the type explicitly set by the RHS or, if none, to the type named by the <cite>type</cite> call on the LHS. If the LHS has none because it&#8217;s a <cite>dom(...)</cite> LHS, an error is raised.</p>
<p>When you query for fnodes of a certain type, you can expect to find notes of any form you specified on any RHS with that type. If no note is specified, it will be undefined. However, if two RHSs emits a given type, one adding a note and the other not adding one (or adding an undefined one), the meaningful note overrides the undefined one. This allows elaboration on a RHS&#8217;s score (for example) without needing to repeat note logic.</p>
<p>Indeed, <code class="docutils literal"><span class="pre">undefined</span></code> is not considered a note. So, though notes cannot in general be overwritten, a note that is <code class="docutils literal"><span class="pre">undefined</span></code> can. Symmetrically, an <code class="docutils literal"><span class="pre">undefined</span></code> returned from a <code class="docutils literal"><span class="pre">note</span></code> or <a class="reference internal" href="#props" title="props"><code class="xref js js-func docutils literal"><span class="pre">props()</span></code></a> or the like will quietly decline to overwrite an existing defined note, where any other value would cause an error. Rationale: letting <code class="docutils literal"><span class="pre">undefined</span></code> be a valid note value would mean you couldn&#8217;t shadow a leftward note in a RHS without introducing a new singleton value to serve as a &#8220;no value&#8221; flag. It&#8217;s not worth the complexity and the potential differences between the (internal) fact and fnode note value semantics.</p>
<p>Best practice: any rule adding a type should apply the same note. If only one rule of several type-foo-emitting ones did, it should be made to emit a different type instead so downstream rules can explicitly state that they require the note to be there. Otherwise, there is nothing to guarantee the note-adding rule will run before the note-needing one.</p>
</dd></dl>

<dl class="function">
<dt id="out">
<code class="descname">out</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#out" title="Permalink to this definition">¶</a></dt>
<dd><p>Expose the output of this rule&#8217;s LHS as a &#8220;final result&#8221; to the surrounding
program. It will be available by calling <a class="reference internal" href="#BoundRuleset.get" title="BoundRuleset.get"><code class="xref js js-func docutils literal"><span class="pre">get()</span></code></a> on the
ruleset and passing the key. You can run the nodes through a callback
function first by adding <a class="reference internal" href="#through" title="through"><code class="xref js js-func docutils literal"><span class="pre">through()</span></code></a>.</p>
<dl class="function">
<dt id="through">
<code class="descname">through</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#through" title="Permalink to this definition">¶</a></dt>
<dd><p>Append <code class="docutils literal"><span class="pre">.through</span></code> to <a class="reference internal" href="#out" title="out"><code class="xref js js-func docutils literal"><span class="pre">out()</span></code></a> to run the nodes emitted from the LHS
through an arbitrary function before returning them to the containing
program. Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">(</span><span class="s1">&#39;titleLengths&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">through</span><span class="p">(</span><span class="n">fnode</span> <span class="o">=&gt;</span> <span class="n">fnode</span><span class="o">.</span><span class="n">noteFor</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="score">
<code class="descname">score</code><span class="sig-paren">(</span><em>scoreOrCallback</em><span class="sig-paren">)</span><a class="headerlink" href="#score" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply the score of the input node by some number, which can be &gt;1 to
increase the score or &lt;1 to decrease it.</p>
<p>Since every node can have multiple, independent scores (one for each type),
this applies to the type explicitly set by the RHS or, if none, to the type
named by the <code class="docutils literal"><span class="pre">type</span></code> call on the LHS. If the LHS has none because it&#8217;s a
<code class="docutils literal"><span class="pre">dom(...)</span></code> LHS, an error is raised.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><ul class="first last simple">
<li><strong>scoreOrCallback</strong> (<em>number|function</em>) &#8211; Can either be a static number or
else a callback which takes the fnode and returns a number.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="type">
<code class="descname">type</code><span class="sig-paren">(</span><em>theType</em><span class="sig-paren">)</span><a class="headerlink" href="#type" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the type applied to fnodes processed by this RHS.</p>
</dd></dl>

<dl class="function">
<dt id="typeIn">
<code class="descname">typeIn</code><span class="sig-paren">(</span><em>type</em><span class="optional">[</span>, <em>type</em>, <em>...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#typeIn" title="Permalink to this definition">¶</a></dt>
<dd><p>Constrain this rule to emit 1 of a set of given types. Pass no args to lift
a previous <code class="docutils literal"><span class="pre">typeIn</span></code> constraint, as you might do when basing a LHS on a
common value to factor out repetition.</p>
<p><code class="docutils literal"><span class="pre">typeIn</span></code> is mostly a hint for the query planner when you&#8217;re emitting types
dynamically from <code class="docutils literal"><span class="pre">props</span></code> calls—in fact, an error will be raised if
<code class="docutils literal"><span class="pre">props</span></code> is used without a <code class="docutils literal"><span class="pre">typeIn</span></code> or <code class="docutils literal"><span class="pre">type</span></code> to constrain it—but it
also checks conformance at runtime to ensure validity.</p>
</dd></dl>

</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="utilities.html" class="btn btn-neutral float-right" title="Utility Functions" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="using.html" class="btn btn-neutral" title="Using Fathom" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Mozilla Foundation.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>